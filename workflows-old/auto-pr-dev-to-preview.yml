# .github/workflows/auto-pr-dev-to-preview.yml
name: Auto PR dev → preview

on:
  push:
    branches: [ dev ]
  pull_request:
    types: [ closed ]
    branches: [ dev ]

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: auto-pr-dev-to-preview
  cancel-in-progress: false

jobs:
  open-pr:
    if: |
      (github.event_name == 'push' && startsWith(github.ref, 'refs/heads/dev')) ||
      (github.event_name == 'pull_request' &&
       github.event.pull_request.merged == true &&
       github.base_ref == 'dev')
    runs-on: ubuntu-latest
    steps:
      - name: Générer release notes & ouvrir/mettre à jour PR dev → preview
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = 'dev';
            const base = 'preview';

            // 1) Dernier tag publié (si présent)
            let previousTag = null;
            try {
              const latest = await github.rest.repos.getLatestRelease({ owner, repo });
              previousTag = latest.data.tag_name;
              core.info(`Dernière release détectée: ${previousTag}`);
            } catch (e) {
              core.warning(`Aucune release publiée détectée (première release ?): ${e.message}`);
            }

            // 2) Générer release notes (officiel GitHub)
            //    - target_commitish = dev
            //    - previous_tag_name = dernier tag (si connu)
            //    - tag_name peut être “virtuel” (on ne publie pas ici)
            let releaseNotesBody = '';
            try {
              const rn = await github.rest.repos.generateReleaseNotes({
                owner, repo,
                tag_name: `dev-preview-${new Date().toISOString().slice(0,10)}`,
                target_commitish: head,
                ...(previousTag ? { previous_tag_name: previousTag } : {})
              });
              releaseNotesBody = rn.data.body || '';
            } catch (e) {
              core.warning(`Echec generateReleaseNotes, fallback sur compare: ${e.message}`);
              // Fallback officiel: Compare preview...dev (commits bruts)
              const cmp = await github.rest.repos.compareCommits({ owner, repo, base, head });
              const list = cmp.data.commits.map(c => `- ${c.commit.message.split('\n')[0]} (${c.sha.substring(0,7)})`);
              releaseNotesBody = list.length
                ? `### Changelog (fallback compare ${base}...${head})\n` + list.join('\n')
                : `### Changelog\nAucun diff entre ${base} et ${head}.`;
            }

            // 3) Préparer corps standard de la PR
            const title = 'chore: sync dev → preview';
            const header = `## Release notes (auto)\n\n${releaseNotesBody}\n`;
            const footer = `\n---\n- Source: \`${head}\`\n- Cible: \`${base}\`\n> Notes générées via API GitHub (Generate release notes).`;

            // 4) Chercher PR existante dev → preview
            const openPRs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', head: `${owner}:${head}`, base }
            );

            if (openPRs.length > 0) {
              const current = openPRs[0];
              const newBody = `${header}${footer}\n\n${current.body ?? ''}`;
              await github.rest.pulls.update({
                owner, repo, pull_number: current.number, title, body: newBody
              });
              core.info(`PR mise à jour: #${current.number} (${current.html_url})`);
              return;
            }

            // 5) Créer la PR avec le changelog injecté
            const body = `${header}${footer}`;
            const pr = await github.rest.pulls.create({
              owner, repo, title, head, base, body, draft: false, maintainer_can_modify: true
            });
            core.info(`PR créée: #${pr.data.number} (${pr.data.html_url})`);

            // (Optionnel) Label d’automatisation
            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: pr.data.number, labels: ['automation']
              });
            } catch (e) {
              core.warning(`Impossible d’ajouter le label (optionnel): ${e.message}`);
            }
