# .github/workflows/release-on-merge-preview.yml
name: Release on merge → preview (auto notes)

on:
  pull_request:
    types: [ closed ]
    branches: [ preview ]   # adapte si ta branche de préprod a un autre nom

permissions:
  contents: write           # requis pour créer la release (tag, notes)

concurrency:
  group: release-on-merge-preview
  cancel-in-progress: false

jobs:
  make-release:
    # Ne lance que si la PR a été MERGÉE et que la base est bien 'preview'
    if: github.event.pull_request.merged == true && github.base_ref == 'preview'
    runs-on: ubuntu-latest
    steps:
      - name: Créer la release avec changelog auto
        uses: actions/github-script@v7
        with:
            script: |
                const { owner, repo } = context.repo;

                // ✅ Toujours récupérer la PR depuis le payload JS
                const pr = context.payload.pull_request;
                if (!pr) {
                    core.setFailed('Ce job doit être déclenché par un event pull_request.');
                    return;
                }

                const baseBranch = pr.base.ref;              // ex: 'preview'
                const headBranch = pr.head.ref;              // ex: 'dev'
                const prNumber   = pr.number;

                // 1) Dernier tag publié (si existant)
                let previousTag = null;
                try {
                    const latest = await github.rest.repos.getLatestRelease({ owner, repo });
                    previousTag = latest.data.tag_name;
                    core.info(`Dernière release: ${previousTag}`);
                } catch (e) {
                    core.warning(`Aucune release publiée détectée: ${e.message}`);
                }

                // 2) Bump SemVer simple (pilotable par labels release:major|minor|patch)
                const bumpLabel = (pr.labels || []).map(l => l.name).find(n => /^release:(major|minor|patch)$/.test(n)) || 'release:patch';
                const bump = (tag, type) => {
                    if (!tag || !/^v?\d+\.\d+\.\d+/.test(tag)) return 'v0.1.0';
                    const [M,m,p] = tag.replace(/^v/,'').split('.').map(Number);
                    if (type.endsWith('major')) return `v${M+1}.0.0`;
                    if (type.endsWith('minor')) return `v${M}.${m+1}.0`;
                    return `v${M}.${m}.${p+1}`;
                };
                const nextTag = bump(previousTag, bumpLabel);
                core.info(`Prochain tag: ${nextTag} (${bumpLabel})`);

                // 3) Release notes (officiel) avec fallback
                let notesBody = '';
                try {
                    const rn = await github.rest.repos.generateReleaseNotes({
                    owner, repo,
                    tag_name: nextTag,
                    target_commitish: baseBranch,
                    ...(previousTag ? { previous_tag_name: previousTag } : {})
                    });
                    notesBody = rn.data.body || '';
                } catch (e) {
                    core.warning(`Échec generateReleaseNotes → fallback compare: ${e.message}`);
                    const base = previousTag ?? `${baseBranch}~1`;
                    const cmp  = await github.rest.repos.compareCommits({ owner, repo, base, head: baseBranch });
                    notesBody  = cmp.data.commits.map(c => `- ${c.commit.message.split('\n')[0]} (${c.sha.slice(0,7)})`).join('\n') || 'Aucun changement détecté.';
                }

                // 4) Créer la release (pré-release sur preview)
                const title = `${nextTag} – merge #${prNumber} → ${baseBranch}`;
                const body  = `**Source PR**: #${prNumber}\n**Branche**: \`${baseBranch}\` (depuis \`${headBranch}\`)\n\n---\n\n${notesBody}`;
                const rel = await github.rest.repos.createRelease({
                    owner, repo,
                    tag_name: nextTag,
                    name: title,
                    body,
                    target_commitish: baseBranch,
                    draft: false,
                    prerelease: true
                });
                core.info(`Release créée: ${rel.data.html_url}`);
