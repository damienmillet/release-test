name: Release on merge → preview (auto notes)

on:
  pull_request:
    types: [ closed ]
    branches: [ preview ]

permissions:
  contents: write

concurrency:
  group: release-on-merge-preview
  cancel-in-progress: false

jobs:
  make-release:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Create pre-release (-beta) with grouped notes
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            if (!pr) { core.setFailed('This job must be triggered by a pull_request event.'); return; }

            const baseBranch = pr.base.ref; // preview
            const headBranch = pr.head.ref; // usually dev

            // 1) Latest tag
            let previousTag = null;
            try {
              const latest = await github.rest.repos.getLatestRelease({ owner, repo });
              previousTag = latest.data.tag_name;
              core.info(`Latest release: ${previousTag}`);
            } catch (e) {
              core.warning(`No published release yet: ${e.message}`);
            }

            // 2) Next base tag by PR label (release:major|minor|patch)
            const label = (pr.labels || []).map(l => l.name).find(n => /^release:(major|minor|patch)$/.test(n)) || 'release:patch';
            const bump = (tag, type) => {
              if (!tag || !/^v?\d+\.\d+\.\d+$/.test(tag)) return 'v0.1.0';
              const [M,m,p] = tag.replace(/^v/,'').split('.').map(Number);
              if (type.endsWith('major')) return `v${M+1}.0.0`;
              if (type.endsWith('minor')) return `v${M}.${m+1}.0`;
              return `v${M}.${m}.${p+1}`;
            };
            const baseTag = bump(previousTag, label);
            const betaTag = `${baseTag}-beta`;

            // 3) Build grouped notes via compare (filter merges + bot)
            const baseForCompare = previousTag ?? `${baseBranch}~1`;
            const cmp = await github.rest.repos.compareCommits({ owner, repo, base: baseForCompare, head: baseBranch });

            const filtered = (cmp.data.commits || []).filter(c => {
              const isMerge = (Array.isArray(c.parents) ? c.parents.length : 0) > 1 || /^Merge\b/i.test(c.commit.message);
              const isBot   = c.author?.login === 'github-actions[bot]'
                           || /github-actions\[bot\]/i.test(c.commit?.author?.name || '')
                           || /actions@github\.com/i.test(c.commit?.author?.email || '');
              return !isMerge && !isBot;
            });

            const groups = { feat:[], fix:[], perf:[], refactor:[], docs:[], test:[], build:[], ci:[], chore:[], other:[] };
            const extract = (msg) => {
              const m = msg.match(/^(\w+)(\([\w\-\.]+\))?(!)?:\s+(.+)/);
              const type = m?.[1]?.toLowerCase();
              const subject = (m?.[4] ?? msg).split('\n')[0].trim();
              return { type, subject };
            };
            const prRef = (msg) => {
              const m = msg.match(/\(#(\d+)\)/);
              return m ? ` #${m[1]}` : '';
            };

            for (const c of filtered) {
              const { type, subject } = extract(c.commit.message);
              const line = `- ${subject}${prRef(c.commit.message)} (${c.sha.slice(0,7)})`;
              if (type && groups[type]) groups[type].push(line); else groups.other.push(line);
            }

            const order  = ['feat','fix','perf','refactor','docs','test','build','ci','chore','other'];
            const titles = {
              feat:'✨ Features', fix:'🐞 Fixes', perf:'⚡️ Performance', refactor:'♻️ Refactor',
              docs:'📝 Docs', test:'✅ Tests', build:'🏗 Build', ci:'🤖 CI', chore:'🧹 Chore', other:'🔹 Others'
            };
            const sections = order
              .filter(k => groups[k].length)
              .map(k => `### ${titles[k]}\n${groups[k].join('\n')}`)
              .join('\n\n');

            const notes = sections || 'No changes detected.';

            // 4) Create pre-release (tag + title in -beta)
            const title = betaTag;
            const body  = notes;

            const rel = await github.rest.repos.createRelease({
              owner, repo,
              tag_name: betaTag,
              name: title,
              body,
              target_commitish: baseBranch,
              draft: false,
              prerelease: true
            });
            core.info(`Pre-release created: ${rel.data.html_url}`);
