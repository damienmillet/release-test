name: Auto PR preview ‚Üí main

on:
  push:
    branches: [ preview ]
  pull_request:
    types: [ closed ]
    branches: [ preview ]

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: auto-pr-preview-to-main
  cancel-in-progress: false

jobs:
  open-pr:
    # Les triggers filtrent d√©j√† la branche; on garde "merged == true" pour le cas PR
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    runs-on: ubuntu-latest
    steps:
      - name: Ouvrir/mettre √† jour la PR preview ‚Üí main (changelog group√©)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = 'preview';
            const base = 'main';

            // 1) Diff r√©el main...preview
            const compare = await github.rest.repos.compareCommits({ owner, repo, base, head });
            const commits = compare.data.commits || [];
            if (commits.length === 0) {
              core.info(`Aucun diff entre ${base} et ${head} ‚Äî pas de PR √† cr√©er.`);
              return;
            }

            // 2) Regroupement Conventional Commits
            const groups = { feat:[], fix:[], perf:[], refactor:[], docs:[], test:[], build:[], ci:[], chore:[], other:[] };
            const extract = (msg) => {
              // type(scope)!: subject  |  subject (#123)
              const m = msg.match(/^(\w+)(\([\w\-\.]+\))?(!)?:\s+(.+)/);
              const type = m?.[1]?.toLowerCase();
              const subject = (m?.[4] ?? msg).split('\n')[0].trim();
              return { type, subject };
            };
            // ‚úÖ regex corrig√©e
            const prRef = (msg) => {
              const m = msg.match(/\(#(\d+)\)/);
              return m ? ` #${m[1]}` : '';
            };

            for (const c of commits) {
              const { type, subject } = extract(c.commit.message);
              const line = `- ${subject}${prRef(c.commit.message)}`;
              if (type && groups[type]) groups[type].push(line);
              else groups.other.push(line);
            }

            const order  = ['feat','fix','perf','refactor','docs','test','build','ci','chore','other'];
            const titles = {
              feat:'‚ú® Features', fix:'üêû Fixes', perf:'‚ö°Ô∏è Performance', refactor:'‚ôªÔ∏è Refactor',
              docs:'üìù Docs', test:'‚úÖ Tests', build:'üèó Build', ci:'ü§ñ CI', chore:'üßπ Chore', other:'üîπ Others'
            };
            const sections = order
              .filter(k => groups[k].length)
              .map(k => `### ${titles[k]}\n${groups[k].join('\n')}`)
              .join('\n\n');

            const changelog = `## Changelog (${head} ‚Üí ${base})\n\n_Comparaison_: \`${base}...${head}\`\n\n${sections}`;

            // 3) Bloc idempotent + empreinte de diff
            const START  = '<!-- AUTO-PR-CHANGELOG:START -->';
            const END    = '<!-- AUTO-PR-CHANGELOG:END -->';
            const DIFF   = `<!-- AUTO-PR-DIFF:${commits.map(c => c.sha).join(',')} -->`;
            const footer = '\n\n> Changelog regroup√© automatiquement (GitHub Actions).';
            const section = `${START}\n${DIFF}\n${changelog}\n${footer}\n${END}`;

            const title  = 'chore: promote preview ‚Üí main';

            // 4) Utilitaire de remplacement par indices (pas de RegExp fragile)
            const replaceBlock = (prev, block) => {
              const s = prev.indexOf(START);
              const e = prev.indexOf(END);
              if (s !== -1 && e !== -1 && e > s) {
                return prev.slice(0, s) + block + prev.slice(e + END.length);
              }
              // pas de bloc : on pr√©fixe une seule fois
              return `${block}\n\n${prev}`;
            };

            // 5) PR existante ?
            const openPRs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', head: `${owner}:${head}`, base }
            );

            if (openPRs.length > 0) {
              const current = openPRs[0];
              const prev = (current.body ?? '').trim();

              // Si bloc pr√©sent, comparer l'empreinte DIFF
              const s = prev.indexOf(START);
              const e = prev.indexOf(END);
              if (s !== -1 && e !== -1 && e > s) {
                const existingBlock = prev.slice(s, e + END.length);
                const existingDiff = existingBlock.match(/<!-- AUTO-PR-DIFF:([^-]+)-->/)?.[1]?.trim() ?? '';
                const newDiff = commits.map(c => c.sha).join(',');
                if (existingDiff === newDiff) {
                  core.info('PR d√©j√† √† jour (empreinte identique), aucune modification.');
                  return;
                }
              }

              const newBody = replaceBlock(prev, section);
              if (newBody !== prev) {
                await github.rest.pulls.update({ owner, repo, pull_number: current.number, title, body: newBody });
                core.info(`PR mise √† jour: #${current.number} (${current.html_url})`);
              } else {
                core.info('Aucune modification n√©cessaire.');
              }
              return;
            }

            // 6) Cr√©er la PR avec le bloc directement
            const body = section;
            const pr = await github.rest.pulls.create({
              owner, repo, title, head, base, body, draft: false, maintainer_can_modify: true
            });
            core.info(`PR cr√©√©e: #${pr.data.number} (${pr.data.html_url})`);

            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: pr.data.number, labels: ['automation']
              });
            } catch (e) {
              core.warning(`Label non ajout√© (optionnel): ${e.message}`);
            }
