name: Release on merge â†’ main (auto notes)

on:
  pull_request:
    types: [ closed ]
    branches: [ main ]

permissions:
  contents: write

concurrency:
  group: release-on-merge-main
  cancel-in-progress: false

jobs:
  make-release:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Create stable release with filtered notes and delete unchanged beta
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const pr = context.payload.pull_request;
            if (!pr) { 
              core.setFailed('This job must be triggered by a pull_request event.'); 
              return; 
            }

            const baseBranch = pr.base.ref; // main

            // 1) Latest tag
            let previousTag = null;
            try {
              const latest = await github.rest.repos.getLatestRelease({ owner, repo });
              previousTag = latest.data.tag_name; // e.g. v1.2.3
              core.info(`Latest release: ${previousTag}`);
            } catch (e) {
              core.warning(`No published release yet: ${e.message}`);
            }

            // 2) Next tag by PR label release:major|minor|patch (default: patch)
            const label = (pr.labels || []).map(l => l.name)
              .find(n => /^release:(major|minor|patch)$/.test(n)) || 'release:patch';
            const bump = (tag, type) => {
              if (!tag || !/^v?\d+\.\d+\.\d+$/.test(tag)) return 'v1.0.0';
              const [M,m,p] = tag.replace(/^v/,'').split('.').map(Number);
              if (type.endsWith('major')) return `v${M+1}.0.0`;
              if (type.endsWith('minor')) return `v${M}.${m+1}.0`;
              return `v${M}.${m}.${p+1}`;
            };
            const nextTag = bump(previousTag, label);
            const betaTag = `${nextTag}-beta`;

            // 3) Build notes via compare (filter merges + github-actions[bot])
            const baseForCompare = previousTag ?? `${baseBranch}~1`;
            const cmp = await github.rest.repos.compareCommits({ owner, repo, base: baseForCompare, head: baseBranch });

            const commits = (cmp.data.commits || []).filter(c => {
              const isMerge = (Array.isArray(c.parents) ? c.parents.length : 0) > 1 || /^Merge\b/i.test(c.commit.message);
              const isBot   = c.author?.login === 'github-actions[bot]'
                           || /github-actions\[bot\]/i.test(c.commit?.author?.name || '')
                           || /actions@github\.com/i.test(c.commit?.author?.email || '');
              return !isMerge && !isBot;
            });

            const lines = commits.map(c => `- ${c.commit.message.split('\n')[0]} (${c.sha.slice(0,7)})`);
            const notes = lines.length ? lines.join('\n') : 'No changes detected.';

            // 4) Create stable release (name = vX.Y.Z)
            const title = `${nextTag}`;
            const body  = [ notes ].join('\n');

            const release = await github.rest.repos.createRelease({
              owner, repo,
              tag_name: nextTag,
              name: title,
              body,
              target_commitish: baseBranch,
              draft: false,
              prerelease: false
            });
            core.info(`Release created: ${release.data.html_url}`);

            // 5) If there is a prerelease vX.Y.Z-beta AND nothing changed since it, delete it + its tag
            try {
              // get prerelease by tag
              const beta = await github.rest.repos.getReleaseByTag({ owner, repo, tag: betaTag });

              // compare commits from beta tag to main
              const cmpBeta = await github.rest.repos.compareCommits({ owner, repo, base: betaTag, head: baseBranch });
              const commitsBeta = (cmpBeta.data.commits || []).filter(c => {
                const isMerge = (Array.isArray(c.parents) ? c.parents.length : 0) > 1 || /^Merge\b/i.test(c.commit.message);
                const isBot   = c.author?.login === 'github-actions[bot]'
                             || /github-actions\[bot\]/i.test(c.commit?.author?.name || '')
                             || /actions@github\.com/i.test(c.commit?.author?.email || '');
                return !isMerge && !isBot;
              });

              if (commitsBeta.length === 0) {
                // delete the prerelease
                await github.rest.repos.deleteRelease({ owner, repo, release_id: beta.data.id });
                core.info(`Pre-release ${betaTag} deleted (no changes since beta).`);
                // delete the tag refs/tags/vX.Y.Z-beta
                try {
                  await github.rest.git.deleteRef({ owner, repo, ref: `tags/${betaTag}` });
                  core.info(`Tag refs/tags/${betaTag} deleted.`);
                } catch (e) {
                  core.warning(`Could not delete tag ${betaTag}: ${e.message}`);
                }
              } else {
                core.info(`Pre-release ${betaTag} kept (changes detected since beta).`);
              }
            } catch (e) {
              core.info(`No prerelease tag ${betaTag} found or cannot fetch it: ${e.message}`);
            }
