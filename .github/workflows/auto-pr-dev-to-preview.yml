name: Auto PR dev → preview

on:
  push:
    branches: [ dev ]
  pull_request:
    types: [ closed ]
    branches: [ dev ]

permissions:
  contents: read
  pull-requests: write

concurrency:
  group: auto-pr-dev-to-preview
  cancel-in-progress: false

jobs:
  open-pr:
    if: github.event_name == 'push' || (github.event_name == 'pull_request' && github.event.pull_request.merged == true)
    runs-on: ubuntu-latest
    steps:
      - name: Prepare grouped changelog & open/update PR dev → preview (overwrite body)
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = 'dev';
            const base = 'preview';

            // 1) Compare preview...dev
            const compare = await github.rest.repos.compareCommits({ owner, repo, base, head });

            // Exclude merges and github-actions[bot]
            const all = compare.data.commits || [];
            const commits = all.filter(c => {
              const isMerge = (Array.isArray(c.parents) ? c.parents.length : 0) > 1 || /^Merge\b/i.test(c.commit.message);
              const isBot   = c.author?.login === 'github-actions[bot]'
                           || /github-actions\[bot\]/i.test(c.commit?.author?.name || '')
                           || /actions@github\.com/i.test(c.commit?.author?.email || '');
              return !isMerge && !isBot;
            });

            // 2) Resolve next base tag (pre-release flow)
            let previousTag = null;
            try {
              const latest = await github.rest.repos.getLatestRelease({ owner, repo });
              previousTag = latest.data.tag_name; // e.g. v1.2.3
              core.info(`Latest release: ${previousTag}`);
            } catch (e) {
              core.warning(`No published release yet: ${e.message}`);
            }

            // Bump hint from commit messages: release:major|minor|patch (default: patch)
            const bumpHint = (commits
              .map(c => c.commit.message.match(/release:(major|minor|patch)/i)?.[1]?.toLowerCase())
              .filter(Boolean).pop()) || 'patch';

            const bump = (tag, type='patch') => {
              if (!tag || !/^v?\d+\.\d+\.\d+$/.test(tag)) {
                if (type === 'major') return 'v1.0.0';
                if (type === 'minor') return 'v0.1.0';
                return 'v0.1.1';
              }
              const [M,m,p] = tag.replace(/^v/,'').split('.').map(Number);
              if (type === 'major') return `v${M+1}.0.0`;
              if (type === 'minor') return `v${M}.${m+1}.0`;
              return `v${M}.${m}.${p+1}`;
            };
            const nextTag  = bump(previousTag, bumpHint);
            const nextBeta = `${nextTag}-beta`;

            // 2bis) Date pour le titre
            const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD

            // 3) Group by Conventional Commits
            const groups = { feat:[], fix:[], perf:[], refactor:[], docs:[], test:[], build:[], ci:[], chore:[], other:[] };
            const extract = (msg) => {
              // type(scope)!: subject  |  subject (#123)
              const m = msg.match(/^(\w+)(\([\w\-\.]+\))?(!)?:\s+(.+)/);
              const type = m?.[1]?.toLowerCase();
              const subject = (m?.[4] ?? msg).split('\n')[0].trim();
              return { type, subject };
            };
            const prRef = (msg) => {
              const m = msg.match(/\(#(\d+)\)/);
              return m ? ` #${m[1]}` : '';
            };

            for (const c of commits) {
              const { type, subject } = extract(c.commit.message);
              const line = `- ${subject}${prRef(c.commit.message)}`;
              if (type && groups[type]) groups[type].push(line); else groups.other.push(line);
            }

            const order  = ['feat','fix','perf','refactor','docs','test','build','ci','chore','other'];
            const titles = {
              feat:'✨ Features', fix:'🐞 Fixes', perf:'⚡️ Performance', refactor:'♻️ Refactor',
              docs:'📝 Docs', test:'✅ Tests', build:'🏗 Build', ci:'🤖 CI', chore:'🧹 Chore', other:'🔹 Others'
            };
            const sections = order.filter(k => groups[k].length).map(k => `### ${titles[k]}\n${groups[k].join('\n')}`).join('\n\n');

            const changelog = sections
              ? `## Changelog ${nextBeta}\n\n${sections}`
              : `## Changelog ${nextBeta}\n\n_No differential commits._`;

            // 4) Single block + DIFF fingerprint
            const START  = '<!-- AUTO-PR-CHANGELOG:START -->';
            const END    = '<!-- AUTO-PR-CHANGELOG:END -->';
            const DIFF   = `<!-- AUTO-PR-DIFF:${commits.map(c => c.sha).join(',')} -->`;
            const footer = `\n\n> Changelog generated automatically (GitHub Actions).`;
            const section = `${START}\n${DIFF}\n${changelog}\n${footer}\n${END}`;

            // Titre AVEC date
            const title = `sync: dev → preview ${nextBeta} (${today})`;

            // 5) Find existing PR dev→preview
            const openPRs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', head: `${owner}:${head}`, base }
            );

            if (openPRs.length > 0) {
              const current = openPRs[0];
              const newBody = section;
              if ((current.body ?? '') !== newBody || current.title !== title) {
                await github.rest.pulls.update({ owner, repo, pull_number: current.number, title, body: newBody });
                core.info(`PR updated (body overwritten): #${current.number} (${current.html_url})`);
              } else {
                core.info('PR already up to date, no change.');
              }
              return;
            }

            // 6) Create PR with the block
            const body = section;
            const pr = await github.rest.pulls.create({
              owner, repo, title, head, base, body, draft: false, maintainer_can_modify: true
            });
            core.info(`PR created: #${pr.data.number} (${pr.data.html_url})`);

            try {
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.data.number, labels: ['automation'] });
            } catch (e) {
              core.warning(`Optional label not added: ${e.message}`);
            }
